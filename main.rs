use std::fs;
use std::path::Path;
use std::time::SystemTime;
use regex::Regex;
use std::str::FromStr;

use sysinfo::{System, Pid};
use winapi::um::processthreadsapi::OpenProcess;
use winapi::um::winnt::{PROCESS_VM_READ, PROCESS_QUERY_INFORMATION};
use winapi::um::memoryapi::ReadProcessMemory;
use winapi::um::handleapi::CloseHandle;

const PROCESS_ALL_ACCESS: u32 = PROCESS_VM_READ | PROCESS_QUERY_INFORMATION;

#[repr(C)]
struct GameObject {
    parent: usize,     // 0x60
    children: usize,   // 0x50
    name: usize,       // 0x48
    local_player: usize, // 0x240
    class_name: usize,  // 0x18
}

fn main() {
    let mut sys = System::new_all();
    sys.refresh_all();
    let process = sys.processes_by_name("RobloxPlayerBeta").next();

    let process_id = match process {
        Some(process) => process.pid(),
        None => {
            println!("Roblox not running.");
            return;
        }
    };

    println!("Roblox pID: {}", process_id);

    let folder_path = "C:\\Users\\prest\\AppData\\Local\\Roblox\\logs";

    let earliest_log = find_earliest_log(folder_path).expect("Failed to find the log file.");

    let log_content = fs::read_to_string(&earliest_log).expect("Failed to read log file");

    if let Some(datamodel_address) = find_datamodel_address(&log_content) {
        println!("Datamodel address: {}", datamodel_address);

        if let Some(game_object) = read_game_object(process_id, usize::from_str_radix(&datamodel_address, 16).unwrap()) {

            println!("Parent: 0x{:X}", game_object.parent);
            println!("Children: 0x{:X}", game_object.children);
            println!("Name: 0x{:X}", game_object.name);
            println!("LocalPlayer: 0x{:X}", game_object.local_player);
            println!("ClassName: 0x{:X}", game_object.class_name);

            let parent_name = read_string(process_id.as_u32(), game_object.name);
            let local_player_name = read_string(process_id.as_u32(), game_object.local_player);

            println!("Parent Name: {}", parent_name.unwrap_or("N/A".to_string()));
            println!("LocalPlayer Name: {}", local_player_name.unwrap_or("N/A".to_string()));
        } else {
            println!("Failed to read game object.");
        }
    } else {
        println!("Datamodel address not found in the log file.");
    }
}
fn find_earliest_log(folder_path: &str) -> Option<String> {
    let entries = fs::read_dir(folder_path).expect("Failed to read directory");

    let mut earliest_modified_file: Option<String> = None;
    let mut earliest_modified_time = SystemTime::now();

    for entry in entries {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.is_file() && path.extension().map_or(false, |ext| ext == "log") {
            let metadata = fs::metadata(&path).expect("Failed to read metadata");
            let modified_time = metadata.modified().expect("Failed to get modified time");

            if modified_time < earliest_modified_time {
                earliest_modified_time = modified_time;
                earliest_modified_file = Some(path.to_string_lossy().into_owned());
            }
        }
    }

    earliest_modified_file
}

fn find_datamodel_address(log_content: &str) -> Option<String> {
    let re = Regex::new(r"run\s*dataModel\s*\(\s*([0-9a-fA-F]+)\s*\)").unwrap();

    if let Some(captures) = re.captures(log_content) {
        Some(captures[1].to_string())
    } else {
        None
    }
}

fn read_qword(process_id: u32, address: usize) -> Option<usize> {
    // Open the process
    unsafe {
        let process_handle = winapi::um::processthreadsapi::OpenProcess(
            winapi::um::winnt::PROCESS_VM_READ,
            0,
            process_id,
        );
        if process_handle.is_null() {
            return None;
        }

        let mut buffer: usize = 0;
        let mut bytes_read = 0;
        if ReadProcessMemory(
            process_handle,
            address as _,
            &mut buffer as *mut _ as _,
            std::mem::size_of::<usize>(),
            &mut bytes_read,
        ) == 0
        {
            println!("Failed to read qword at address 0x{:X}", address);
            println!("Error code: {}", winapi::um::errhandlingapi::GetLastError());
            winapi::um::handleapi::CloseHandle(process_handle);
            return None;
        }

        winapi::um::handleapi::CloseHandle(process_handle);
        Some(buffer)
    }
}

fn read_string(process_id: u32, address: usize) -> Option<String> {
    let mut buffer: Vec<u8> = Vec::new();

    unsafe {
        let process_handle = OpenProcess(
            PROCESS_VM_READ,
            0,
            process_id,
        );
        if process_handle.is_null() {
            return None;
        }

        // Read the string from memory
        let mut current_byte: u8 = 0;
        let mut bytes_read = 0;

        while current_byte != 0 {
            if ReadProcessMemory(
                process_handle,
                (address + bytes_read) as _,
                &mut current_byte as *mut _ as _,
                1,
                std::ptr::null_mut(),
            ) == 0
            {
                break;
            }

            buffer.push(current_byte);
            bytes_read += 1;
        }

        // Close the process handle
        CloseHandle(process_handle);
    }

    String::from_utf8(buffer).ok()
}

fn read_game_object(process_id: Pid, address: usize) -> Option<GameObject> {
    let parent = read_qword(process_id.as_u32(), address + 0x60);
    let children = read_qword(process_id.as_u32(), address + 0x50);
    let name = read_qword(process_id.as_u32(), address + 0x48);
    let local_player = read_qword(process_id.as_u32(), address + 0x240);
    let class_name = read_qword(process_id.as_u32(), address + 0x18);

    if let (Some(parent), Some(children), Some(name), Some(local_player), Some(class_name)) =
        (parent, children, name, local_player, class_name)
    {
        Some(GameObject {
            parent,
            children,
            name,
            local_player,
            class_name,
        })
    } else {
        None
    }
}